{"version":3,"sources":["components/Cell.js","components/Maze.js","components/Game.js","App.js","index.js"],"names":["Cell","getStyle","bkColor","_this","props","endCell","visited","borderTop","topWall","borderRight","rightWall","borderBottom","bottomWall","borderLeft","leftWall","backgroundColor","react_default","a","createElement","id","this","style","onMouseOver","updateCell","bind","Component","cell","index","Maze","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","generateMaze","dimension","cells","r","c","push","numOfCells","length","currentCell","Math","floor","random","previousMoves","directionChoices","visitedCount","up","down","pop","randomNum","right","left","map","min","max","setState","margin","height","width","display","gridTemplateColumns","concat","gridTemplateRows","border","state","console","log","_this2","components_Cell","key","Game","components_Maze","App","className","components_Game","ReactDOM","render","src_App_0","document","getElementById"],"mappings":"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","file":"static/js/main.eceba089.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\n\r\nclass Cell extends Component {\r\n  getStyle = () => {\r\n    let bkColor = 'white';\r\n    if(this.props.endCell === true) {\r\n      bkColor = 'red';\r\n    } else {\r\n      if(this.props.visited === true) bkColor = 'green';\r\n    }\r\n\r\n    return {\r\n      borderTop: this.props.topWall ? '1px solid black' : 'none',\r\n      borderRight: this.props.rightWall ? '1px solid black' : 'none',\r\n      borderBottom: this.props.bottomWall ? '1px solid black' : 'none',\r\n      borderLeft: this.props.leftWall ? '1px solid black' : 'none',\r\n      backgroundColor: bkColor\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return(\r\n      <div \r\n        id={this.props.id} \r\n        style={this.getStyle()}\r\n        onMouseOver={this.props.updateCell.bind(this, this.props.id)}\r\n      >\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n// todo: add prop validation\r\n\r\nexport default Cell;","import React, { Component } from 'react';\r\nimport Cell from './Cell';\r\n\r\n// Factory function to create cell objects\r\nfunction cell(index) {\r\n  this.id = index;\r\n  this.topWall = true;\r\n  this.rightWall = true;\r\n  this.bottomWall = true;\r\n  this.leftWall = true;\r\n  this.visited = false;\r\n  this.endCell = false;\r\n}\r\n\r\nclass Maze extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    // The state holds an array of cell objects which represents each space in the maze.\r\n    // These cell objects hold information about each 'wall' of a cell, which will be hidden\r\n    // or shown when the maze itself is generated effectively opening up paths through the maze.\r\n    this.state = {\r\n      cells: []\r\n    }\r\n  }\r\n\r\n  // After the component mounts it will generate the maze.\r\n  componentDidMount() {\r\n    this.generateMaze();\r\n  }\r\n\r\n  // All of the cell objects will be constructed according to the dimension of the maze (dimension \r\n  // will be passed in as a prop). The next step will be to carve out all the possible paths of the \r\n  // maze according to the back-tracking algorithm.\r\n  generateMaze = () => {\r\n    const { dimension } = this.props;\r\n\r\n    let cells = [];\r\n    for(let r = 0; r < dimension; r++) {\r\n      for(let c = 0; c < dimension; c++) {\r\n        cells.push(new cell(r * dimension + c));\r\n      }\r\n    }\r\n\r\n    let numOfCells = cells.length - 1;\r\n    let currentCell = Math.floor(Math.random() * numOfCells);\r\n    let previousMoves = [];\r\n    let directionChoices = [];\r\n    let visitedCount = 0;\r\n    let up = -dimension;\r\n    let down = dimension;\r\n    let right = 1;\r\n    let left = -1;\r\n\r\n    // Check to see which cells are around the current cell, and if they are visited.\r\n    // If they are not visited push the possible direction to an array of possible directions.\r\n    while(visitedCount <= numOfCells) {\r\n      directionChoices = [];\r\n      if (currentCell + up >= 0) {\r\n          if(cells[currentCell + up].visited === false) {\r\n              directionChoices.push(\"up\");\r\n          }\r\n      }\r\n\r\n      if (currentCell + down <= numOfCells) {\r\n          if(cells[currentCell + down].visited === false) {\r\n              directionChoices.push(\"down\");\r\n          }\r\n      }\r\n\r\n      if ((currentCell + 1) % dimension !== 0) {\r\n          if(cells[currentCell + right].visited === false) {\r\n              directionChoices.push(\"right\");\r\n          }\r\n      }\r\n\r\n      if (currentCell % dimension !== 0) {\r\n          if(cells[currentCell + left].visited === false) {\r\n              directionChoices.push(\"left\");\r\n          }\r\n      }\r\n      \r\n      // If all nearby cells have been visited then go back one move and remove that move\r\n      // from the history of all previous moves.\r\n      if (directionChoices.length === 0) {\r\n          currentCell += previousMoves[previousMoves.length - 1];\r\n          previousMoves.pop();\r\n      }\r\n      else {\r\n          ++visitedCount;\r\n      }\r\n    \r\n      // Pick a random number between 0 and the number of possible directions\r\n      let randomNum = Math.floor(Math.random() * (directionChoices.length));\r\n\r\n      // Remove walls on both cells to carve out the path in the direction that was chosen.\r\n      // Then set the currentCell to the moved to cell. Then add this move to the array of\r\n      // previous moves. Mark the moved to cell as visited.\r\n      if (directionChoices[randomNum] === \"up\") {\r\n          cells[currentCell].topWall = false;\r\n          currentCell += up;\r\n          previousMoves.push(up * -1);\r\n          cells[currentCell].bottomWall = false;\r\n          cells[currentCell].visited = true;\r\n      }\r\n      else if (directionChoices[randomNum] === \"right\") {\r\n          cells[currentCell].rightWall = false;\r\n          currentCell += right;\r\n          previousMoves.push(right * -1);\r\n          cells[currentCell].leftWall = false;\r\n          cells[currentCell].visited = true;\r\n      }\r\n      else if (directionChoices[randomNum] === \"down\") {\r\n          cells[currentCell].bottomWall = false;\r\n          currentCell += down;\r\n          previousMoves.push(down * -1);\r\n          cells[currentCell].topWall = false;\r\n          cells[currentCell].visited = true;\r\n      }\r\n      else if (directionChoices[randomNum] === \"left\") {\r\n          cells[currentCell].leftWall = false;\r\n          currentCell += left;\r\n          previousMoves.push(left * -1);\r\n          cells[currentCell].rightWall = false;\r\n          cells[currentCell].visited = true;\r\n      }\r\n    }\r\n\r\n    // Mark all cells back to not visited\r\n    cells.map(cell => cell.visited = false);\r\n\r\n    // Choose and set a random ending cell\r\n    // Chosen cell is a random cell in the top row\r\n    let randomEnd = Math.floor(Math.random() * dimension);\r\n    cells[randomEnd].endCell = true;\r\n\r\n    // Choose and set a random starting cell\r\n    // Chosen cell is a random cell in the bottom row\r\n    let min = cells.length - dimension;\r\n    let max = cells.length;\r\n    let randomStart = Math.floor(Math.random() * (max - min) + min);\r\n\r\n    // Mark start cell as current cell\r\n    cells[randomStart].visited = true;\r\n\r\n    this.setState({cells: cells});\r\n  }\r\n\r\n  getStyle = () => {\r\n    return {\r\n      margin: '0 auto',\r\n      height: '500px',\r\n      width: '500px',\r\n      display: 'grid',\r\n      gridTemplateColumns: `repeat(${this.props.dimension}, auto)`,\r\n      gridTemplateRows: 'auto',\r\n      border: '1px solid black'\r\n    }\r\n  }\r\n\r\n  updateCell = (currentCell) => {\r\n    this.setState(function(state, props) {\r\n      const { dimension } = props;\r\n      let up = -dimension;\r\n      let down = dimension;\r\n      let right = 1;\r\n      let left = -1;\r\n\r\n      let cells = state.cells;\r\n\r\n      // Pseudo Code:\r\n      // check if cell above is valid\r\n        // check if cell above has no bottom wall and current cell has no top wall (pathway open)\r\n          // check if above cell has been visited\r\n            // check if current cell is end cell\r\n              // if it is, win\r\n            // else mark current cell as visited (green)\r\n      if(currentCell + up >= 0) {\r\n        if(cells[currentCell].topWall === false && cells[currentCell + up].bottomWall === false) {\r\n          if(cells[currentCell + up].visited === true) {\r\n            if(cells[currentCell].endCell === true) {\r\n              console.log('you win');\r\n            } else {\r\n              cells[currentCell].visited = true;\r\n              cells[currentCell + up].visited = false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      if(currentCell + down <= cells.length - 1) {\r\n        if(cells[currentCell].bottomWall === false && cells[currentCell + down].topWall === false) {\r\n          if(cells[currentCell + down].visited === true) {\r\n            if(cells[currentCell].endCell === true) {\r\n              console.log('you win');\r\n            } else {\r\n              cells[currentCell].visited = true;\r\n              cells[currentCell + down].visited = false;\r\n            }\r\n          }\r\n        }\r\n      } \r\n      \r\n      if(currentCell + left >= 0) {\r\n        if(cells[currentCell].leftWall === false && cells[currentCell + left].rightWall === false) {\r\n          if(cells[currentCell + left].visited === true) {\r\n            if(cells[currentCell].endCell === true) {\r\n              console.log('you win');\r\n            } else {\r\n              cells[currentCell].visited = true;\r\n              cells[currentCell + left].visited = false;\r\n            }\r\n          }\r\n        }\r\n      } \r\n      \r\n      if(currentCell + right <= cells.length - 1) {\r\n        if(cells[currentCell].rightWall === false && cells[currentCell + right].leftWall === false) {\r\n          if(cells[currentCell + right].visited === true) {\r\n            if(cells[currentCell].endCell === true) {\r\n              console.log('you win');\r\n            } else {\r\n              cells[currentCell].visited = true;\r\n              cells[currentCell + right].visited = false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return {\r\n        cells: cells\r\n      };\r\n    });\r\n  }\r\n\r\n  // This render includes iterating (mapping) through the cells array contained in the maze class state.\r\n  // For each cell, it will create a cell component\r\n  render() {\r\n    return (\r\n      <div style={this.getStyle()}>\r\n        {this.state.cells.map(cell => (\r\n          <Cell\r\n            key={cell.id} \r\n            id={cell.id}\r\n            topWall={cell.topWall}\r\n            rightWall={cell.rightWall}\r\n            bottomWall={cell.bottomWall}\r\n            leftWall={cell.leftWall}\r\n            visited={cell.visited}\r\n            endCell={cell.endCell}\r\n            updateCell={this.updateCell}\r\n          />\r\n        ))}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Maze;\r\n","import React, { Component } from 'react';\r\nimport Maze from './Maze';\r\n\r\nclass Game extends Component {\r\n  render() {\r\n    let dimension = 25;\r\n    return(\r\n      <div>\r\n        <Maze dimension={dimension}/>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Game;","import React, { Component } from 'react';\nimport Game from './components/Game';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <h2>Maze Game</h2>\n          <Game />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n//import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\n//serviceWorker.unregister();\n"],"sourceRoot":""}