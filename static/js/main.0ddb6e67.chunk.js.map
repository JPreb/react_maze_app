{"version":3,"sources":["components/Cell.js","components/Maze.js","components/Menu.js","App.js","index.js"],"names":["Cell","getStyle","bkColor","_this","props","endCell","visited","borderTop","topWall","borderRight","rightWall","borderBottom","bottomWall","borderLeft","leftWall","backgroundColor","react_default","a","createElement","id","this","style","onMouseOver","updateCell","bind","Component","cell","index","Maze","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","generateMaze","dimension","cells","r","c","push","numOfCells","length","currentCell","Math","floor","random","previousMoves","directionChoices","visitedCount","up","down","pop","randomNum","right","left","map","min","max","setState","margin","height","width","display","gridTemplateColumns","concat","gridTemplateRows","border","state","onRouteChange","_this2","components_Cell","key","Menu","onSubmit","onClick","App","route","className","fontSize","components_Menu","components_Maze","ReactDOM","render","src_App_0","document","getElementById"],"mappings":"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","file":"static/js/main.0ddb6e67.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\n\r\nclass Cell extends Component {\r\n  getStyle = () => {\r\n    let bkColor = 'darkgreen';\r\n    if(this.props.endCell === true) {\r\n      bkColor = 'red';\r\n    } else {\r\n      if(this.props.visited === true) bkColor = 'lightgreen';\r\n    }\r\n\r\n    return {\r\n      borderTop: this.props.topWall ? '2px solid black' : 'none',\r\n      borderRight: this.props.rightWall ? '2px solid black' : 'none',\r\n      borderBottom: this.props.bottomWall ? '2px solid black' : 'none',\r\n      borderLeft: this.props.leftWall ? '2px solid black' : 'none',\r\n      backgroundColor: bkColor\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return(\r\n      <div \r\n        id={this.props.id} \r\n        style={this.getStyle()}\r\n        onMouseOver={this.props.updateCell.bind(this, this.props.id)\r\n        }\r\n      >\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Cell;","import React, { Component } from 'react';\r\nimport Cell from './Cell';\r\n\r\n// Factory function to create cell objects\r\nfunction cell(index) {\r\n  this.id = index;\r\n  this.topWall = true;\r\n  this.rightWall = true;\r\n  this.bottomWall = true;\r\n  this.leftWall = true;\r\n  this.visited = false;\r\n  this.endCell = false;\r\n}\r\n\r\nclass Maze extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    // The state holds an array of cell objects which represents each space in the maze.\r\n    // These cell objects hold information about each 'wall' of a cell, which will be hidden\r\n    // or shown when the maze itself is generated effectively opening up paths through the maze.\r\n    this.state = {\r\n      cells: []\r\n    }\r\n  }\r\n\r\n  // After the component mounts it will generate the maze.\r\n  componentDidMount() {\r\n    this.generateMaze();\r\n  }\r\n\r\n  // All of the cell objects will be constructed according to the dimension of the maze (dimension \r\n  // will be passed in as a prop). The next step will be to carve out all the possible paths of the \r\n  // maze according to the back-tracking algorithm.\r\n  generateMaze = () => {\r\n    const { dimension } = this.props;\r\n\r\n    let cells = [];\r\n    for(let r = 0; r < dimension; r++) {\r\n      for(let c = 0; c < dimension; c++) {\r\n        cells.push(new cell(r * dimension + c));\r\n      }\r\n    }\r\n\r\n    let numOfCells = cells.length - 1;\r\n    let currentCell = Math.floor(Math.random() * numOfCells);\r\n    let previousMoves = [];\r\n    let directionChoices = [];\r\n    let visitedCount = 0;\r\n    let up = -dimension;\r\n    let down = dimension;\r\n    let right = 1;\r\n    let left = -1;\r\n\r\n    // Check to see which cells are around the current cell, and if they are visited.\r\n    // If they are not visited push the possible direction to an array of possible directions.\r\n    while(visitedCount <= numOfCells) {\r\n      directionChoices = [];\r\n      if (currentCell + up >= 0) {\r\n          if(cells[currentCell + up].visited === false) {\r\n              directionChoices.push(\"up\");\r\n          }\r\n      }\r\n\r\n      if (currentCell + down <= numOfCells) {\r\n          if(cells[currentCell + down].visited === false) {\r\n              directionChoices.push(\"down\");\r\n          }\r\n      }\r\n\r\n      if ((currentCell + 1) % dimension !== 0) {\r\n          if(cells[currentCell + right].visited === false) {\r\n              directionChoices.push(\"right\");\r\n          }\r\n      }\r\n\r\n      if (currentCell % dimension !== 0) {\r\n          if(cells[currentCell + left].visited === false) {\r\n              directionChoices.push(\"left\");\r\n          }\r\n      }\r\n      \r\n      // If all nearby cells have been visited then go back one move and remove that move\r\n      // from the history of all previous moves.\r\n      if (directionChoices.length === 0) {\r\n          currentCell += previousMoves[previousMoves.length - 1];\r\n          previousMoves.pop();\r\n      }\r\n      else {\r\n          ++visitedCount;\r\n      }\r\n    \r\n      // Pick a random number between 0 and the number of possible directions\r\n      let randomNum = Math.floor(Math.random() * (directionChoices.length));\r\n\r\n      // Remove walls on both cells to carve out the path in the direction that was chosen.\r\n      // Then set the currentCell to the moved to cell. Then add this move to the array of\r\n      // previous moves. Mark the moved to cell as visited.\r\n      if (directionChoices[randomNum] === \"up\") {\r\n          cells[currentCell].topWall = false;\r\n          currentCell += up;\r\n          previousMoves.push(up * -1);\r\n          cells[currentCell].bottomWall = false;\r\n          cells[currentCell].visited = true;\r\n      }\r\n      else if (directionChoices[randomNum] === \"right\") {\r\n          cells[currentCell].rightWall = false;\r\n          currentCell += right;\r\n          previousMoves.push(right * -1);\r\n          cells[currentCell].leftWall = false;\r\n          cells[currentCell].visited = true;\r\n      }\r\n      else if (directionChoices[randomNum] === \"down\") {\r\n          cells[currentCell].bottomWall = false;\r\n          currentCell += down;\r\n          previousMoves.push(down * -1);\r\n          cells[currentCell].topWall = false;\r\n          cells[currentCell].visited = true;\r\n      }\r\n      else if (directionChoices[randomNum] === \"left\") {\r\n          cells[currentCell].leftWall = false;\r\n          currentCell += left;\r\n          previousMoves.push(left * -1);\r\n          cells[currentCell].rightWall = false;\r\n          cells[currentCell].visited = true;\r\n      }\r\n    }\r\n\r\n    // Mark all cells back to not visited\r\n    cells.map(cell => cell.visited = false);\r\n\r\n    // Choose and set a random ending cell\r\n    // Chosen cell is a random cell in the top row\r\n    let randomEnd = Math.floor(Math.random() * dimension);\r\n    cells[randomEnd].endCell = true;\r\n\r\n    // Choose and set a random starting cell\r\n    // Chosen cell is a random cell in the bottom row\r\n    let min = cells.length - dimension;\r\n    let max = cells.length;\r\n    let randomStart = Math.floor(Math.random() * (max - min) + min);\r\n\r\n    // Mark start cell as current cell\r\n    cells[randomStart].visited = true;\r\n\r\n    this.setState({cells: cells});\r\n  }\r\n\r\n  // Styling for grid\r\n  getStyle = () => {\r\n    return {\r\n\r\n      margin: '0 auto',\r\n      height: '85vmin',\r\n      width: '85vmin',\r\n      display: 'grid',\r\n      gridTemplateColumns: `repeat(${this.props.dimension}, auto)`,\r\n      gridTemplateRows: 'auto',\r\n      border: '2px solid black'\r\n    }\r\n  }\r\n\r\n  // This is called when the mouse hovers over a cell. It passes in the cell id and then this function determines\r\n  // if that cell is a valid cell to move to. If it is, it updates the cells array and re-renders the grid with the\r\n  // new cell background color as green.\r\n  updateCell = (currentCell) => {\r\n    this.setState(function(state, props) {\r\n      const { dimension } = props;\r\n      let up = -dimension;\r\n      let down = dimension;\r\n      let right = 1;\r\n      let left = -1;\r\n\r\n      let cells = state.cells;\r\n\r\n      // Check if cell above is valid (not outside bounds of grid/maze)\r\n      if(currentCell + up >= 0) {\r\n        // Check if cell above has no bottom wall and current cell has no top wall (pathway open)\r\n        if(cells[currentCell].topWall === false && cells[currentCell + up].bottomWall === false) {\r\n          // Check if above cell has been visited\r\n          if(cells[currentCell + up].visited === true) {\r\n            // Check if current cell is end cell, if it is, win the game\r\n            if(cells[currentCell].endCell === true) {\r\n              this.props.onRouteChange('StartMenu');\r\n            // If not, mark current cell as visited (green)\r\n            } else {\r\n              cells[currentCell].visited = true;\r\n              cells[currentCell + up].visited = false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Repeat steps above for the remaining cells around the cell the mouse cursor is over\r\n      if(currentCell + down <= cells.length - 1) {\r\n        if(cells[currentCell].bottomWall === false && cells[currentCell + down].topWall === false) {\r\n          if(cells[currentCell + down].visited === true) {\r\n            if(cells[currentCell].endCell === true) {\r\n              this.props.onRouteChange('StartMenu');\r\n            } else {\r\n              cells[currentCell].visited = true;\r\n              cells[currentCell + down].visited = false;\r\n            }\r\n          }\r\n        }\r\n      } \r\n      \r\n      if(currentCell + left >= 0) {\r\n        if(cells[currentCell].leftWall === false && cells[currentCell + left].rightWall === false) {\r\n          if(cells[currentCell + left].visited === true) {\r\n            if(cells[currentCell].endCell === true) {\r\n              this.props.onRouteChange('StartMenu');\r\n            } else {\r\n              cells[currentCell].visited = true;\r\n              cells[currentCell + left].visited = false;\r\n            }\r\n          }\r\n        }\r\n      } \r\n      \r\n      if(currentCell + right <= cells.length - 1) {\r\n        if(cells[currentCell].rightWall === false && cells[currentCell + right].leftWall === false) {\r\n          if(cells[currentCell + right].visited === true) {\r\n            if(cells[currentCell].endCell === true) {\r\n              this.props.onRouteChange('StartMenu');\r\n            } else {\r\n              cells[currentCell].visited = true;\r\n              cells[currentCell + right].visited = false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return {\r\n        cells: cells\r\n      };\r\n    });\r\n  }\r\n\r\n  // This render includes iterating (mapping) through the cells array contained in the maze class state.\r\n  // For each cell, it will create a cell component\r\n  render() {\r\n    return (\r\n      <div style={this.getStyle()}>\r\n        {this.state.cells.map(cell => (\r\n          <Cell\r\n            key={cell.id} \r\n            id={cell.id}\r\n            topWall={cell.topWall}\r\n            rightWall={cell.rightWall}\r\n            bottomWall={cell.bottomWall}\r\n            leftWall={cell.leftWall}\r\n            visited={cell.visited}\r\n            endCell={cell.endCell}\r\n            updateCell={this.updateCell}\r\n          />\r\n        ))}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Maze;\r\n","import React, { Component } from 'react';\r\n\r\nclass Menu extends Component {\r\n  onSubmit = () => {\r\n    this.props.onRouteChange('PlayGame');\r\n  }\r\n  \r\n  render() {\r\n    return (  \r\n      <div>\r\n        <h3>Play Again?</h3>\r\n        <button onClick={this.onSubmit}>Play</button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Menu;","import React, { Component } from 'react';\nimport Maze from './components/Maze';\nimport Menu from './components/Menu';\nimport './App.css';\n\nclass App extends Component {\n  constructor() {\n    super();\n    this.state = {\n      route: 'PlayGame',\n      dimension: 25\n    }\n  }\n\n  onRouteChange = (route) => {\n    this.setState({ route: route });\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <h1 style={{fontSize: '4vmin', margin: '0.5vmin'}}>Maze Game</h1>\n        { this.state.route === 'StartMenu'\n          ? \n          <Menu onRouteChange={this.onRouteChange} />\n          : \n          <div>\n            <Maze dimension={this.state.dimension} onRouteChange={this.onRouteChange} />\n            <h3>Use your mouse to move the green dot to the red dot.</h3>\n          </div>\n        }\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n//import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\n//serviceWorker.unregister();\n"],"sourceRoot":""}