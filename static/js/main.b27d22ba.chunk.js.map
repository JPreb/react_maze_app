{"version":3,"sources":["components/Cell.js","components/Maze.js","components/Game.js","App.js","index.js"],"names":["Cell","getStyle","borderTop","_this","props","topWall","borderRight","rightWall","borderBottom","bottomWall","borderLeft","leftWall","react_default","a","createElement","id","this","style","Component","cell","r","c","visited","Maze","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","generateMaze","dimension","cells","push","numOfCells","length","currentCell","Math","floor","random","previousMoves","directionChoices","visitedCount","up","down","pop","randomNum","right","left","setState","margin","height","width","display","gridTemplateColumns","concat","gridTemplateRows","border","state","map","components_Cell","key","Game","components_Maze","App","className","components_Game","ReactDOM","render","src_App_0","document","getElementById"],"mappings":"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","file":"static/js/main.b27d22ba.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\n\r\nclass Cell extends Component {\r\n  getStyle = () => {\r\n    return {\r\n      borderTop: this.props.topWall ? '1px solid black' : 'none',\r\n      borderRight: this.props.rightWall ? '1px solid black' : 'none',\r\n      borderBottom: this.props.bottomWall ? '1px solid black' : 'none',\r\n      borderLeft: this.props.leftWall ? '1px solid black' : 'none'\r\n    }\r\n  }\r\n\r\n  render() {\r\n    return(\r\n      <div \r\n        id={this.props.id} \r\n        style={this.getStyle()}>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Cell;","import React, { Component } from 'react';\r\nimport Cell from './Cell';\r\n\r\n// Factory function to create cell objects\r\nfunction cell(r, c) {\r\n  this.r = r;\r\n  this.c = c;\r\n  this.topWall = true;\r\n  this.rightWall = true;\r\n  this.bottomWall = true;\r\n  this.leftWall = true;\r\n  this.visited = false;\r\n}\r\n\r\n// MAZE CLASS\r\nclass Maze extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    // The state holds an array of cell objects which represents each space in the maze.\r\n    // These cell objects hold information about each 'wall' of a cell, which will be hidden\r\n    // or shown when the maze itself is generated effectively opening up paths through the maze.\r\n    this.state = {\r\n      cells: []\r\n    }\r\n  }\r\n\r\n  // After the component mounts it will generate the maze.\r\n  componentDidMount() {\r\n    this.generateMaze();\r\n  }\r\n\r\n  // All of the cell objects will be constructed according to the dimension of the maze (dimension \r\n  // will be passed in as a prop). The next step will be to carve out all the possible paths of the \r\n  // maze according to the back-tracking algorithm.\r\n  generateMaze = () => {\r\n    const { dimension } = this.props;\r\n\r\n    let cells = [];\r\n    for(let r = 0; r < dimension; r++) {\r\n      for(let c = 0; c < dimension; c++) {\r\n        cells.push(new cell(r, c));\r\n      }\r\n    }\r\n\r\n    let numOfCells = cells.length - 1;\r\n    let currentCell = Math.floor(Math.random() * numOfCells);\r\n    let previousMoves = [];\r\n    let directionChoices = [];\r\n    let visitedCount = 0;\r\n    let up = -dimension;\r\n    let down = dimension;\r\n    let right = 1;\r\n    let left = -1;\r\n\r\n    // Check to see which cells are around the current cell, and if they are visited.\r\n    // If they are not visited push the possible direction to an array of possible directions.\r\n    while(visitedCount <= numOfCells) {\r\n      directionChoices = [];\r\n      if (currentCell + up >= 0) {\r\n          if(cells[currentCell + up].visited === false) {\r\n              directionChoices.push(\"up\");\r\n          }\r\n      }\r\n\r\n      if (currentCell + down <= numOfCells) {\r\n          if(cells[currentCell + down].visited === false) {\r\n              directionChoices.push(\"down\");\r\n          }\r\n      }\r\n\r\n      if ((currentCell + 1) % dimension !== 0) {\r\n          if(cells[currentCell + right].visited === false) {\r\n              directionChoices.push(\"right\");\r\n          }\r\n      }\r\n\r\n      if (currentCell % dimension !== 0) {\r\n          if(cells[currentCell + left].visited === false) {\r\n              directionChoices.push(\"left\");\r\n          }\r\n      }\r\n      \r\n      // If all nearby cells have been visited then go back one move and remove that move\r\n      // from the history of all previous moves.\r\n      if (directionChoices.length === 0) {\r\n          currentCell += previousMoves[previousMoves.length - 1];\r\n          previousMoves.pop();\r\n      }\r\n      else {\r\n          ++visitedCount;\r\n      }\r\n    \r\n      // Pick a random number between 0 and the number of possible directions\r\n      let randomNum = Math.floor(Math.random() * (directionChoices.length));\r\n\r\n      // Remove walls on both cells to carve out the path in the direction that was chosen.\r\n      // Then set the currentCell to the moved to cell. Then add this move to the array of\r\n      // previous moves. Mark the moved to cell as visited.\r\n      if (directionChoices[randomNum] === \"up\") {\r\n          cells[currentCell].topWall = false;\r\n          currentCell += up;\r\n          previousMoves.push(up * -1);\r\n          cells[currentCell].bottomWall = false;\r\n          cells[currentCell].visited = true;\r\n      }\r\n      else if (directionChoices[randomNum] === \"right\") {\r\n          cells[currentCell].rightWall = false;\r\n          currentCell += right;\r\n          previousMoves.push(right * -1);\r\n          cells[currentCell].leftWall = false;\r\n          cells[currentCell].visited = true;\r\n      }\r\n      else if (directionChoices[randomNum] === \"down\") {\r\n          cells[currentCell].bottomWall = false;\r\n          currentCell += down;\r\n          previousMoves.push(down * -1);\r\n          cells[currentCell].topWall = false;\r\n          cells[currentCell].visited = true;\r\n      }\r\n      else if (directionChoices[randomNum] === \"left\") {\r\n          cells[currentCell].leftWall = false;\r\n          currentCell += left;\r\n          previousMoves.push(left * -1);\r\n          cells[currentCell].rightWall = false;\r\n          cells[currentCell].visited = true;\r\n      }\r\n    }\r\n\r\n    this.setState({cells: cells});\r\n  }\r\n\r\n  getStyle = () => {\r\n    return {\r\n      margin: '0 auto',\r\n      height: '500px',\r\n      width: '500px',\r\n      display: 'grid',\r\n      gridTemplateColumns: `repeat(${this.props.dimension}, auto)`,\r\n      gridTemplateRows: 'auto',\r\n      border: '1px solid black'\r\n    }\r\n  }\r\n\r\n  // This render includes iterating (mapping) through the cells array contained in the maze class state.\r\n  // For each cell, it will create a cell component\r\n  render() {\r\n    return (\r\n      <div style={this.getStyle()}>\r\n        {this.state.cells.map((cell) => (\r\n          <Cell \r\n            key={\"r\" + cell.r + \"c\" + cell.c} \r\n            id={\"r\" + cell.r + \"c\" + cell.c} \r\n            topWall={cell.topWall}\r\n            rightWall={cell.rightWall}\r\n            bottomWall={cell.bottomWall}\r\n            leftWall={cell.leftWall}\r\n          />\r\n        ))}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Maze;\r\n","import React, { Component } from 'react';\r\nimport Maze from './Maze';\r\n\r\nclass Game extends Component {\r\n  render() {\r\n    let dimension = 15;\r\n    return(\r\n      <div>\r\n        <Maze dimension={dimension}/>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Game;","import React, { Component } from 'react';\nimport Game from './components/Game';\nimport './App.css';\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <h2>Maze Game</h2>\n          <Game />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n//import * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\n//serviceWorker.unregister();\n"],"sourceRoot":""}